/**
 * Agent Types - Phase 18
 *
 * Defines the contract for agent adapters that execute PR candidates.
 *
 * @module @gwi/core/agents/types
 */

import { z } from 'zod';
import type {
  PRCandidate,
  WorkItem,
} from '../storage/interfaces.js';
import type { ApprovalScope } from '../run-bundle/types.js';

// =============================================================================
// Implementation Plan Types
// =============================================================================

/**
 * Agent step class categorization for policy enforcement
 * (Distinct from ToolPolicyClass in connectors module)
 */
export const AgentStepClass = z.enum([
  'read_only',      // Safe operations: read files, get PR info
  'informational',  // Comment, label, suggest - no code changes
  'additive',       // Create branches, new files - no destructive ops
  'destructive',    // Commit, push, delete - requires approval
]);

export type AgentStepClass = z.infer<typeof AgentStepClass>;

/**
 * Maps agent step classes to required approval scopes
 */
export const STEP_CLASS_SCOPES: Record<AgentStepClass, ApprovalScope[]> = {
  read_only: [],                                    // No approval needed
  informational: [],                                // No approval needed
  additive: ['commit'],                             // Need commit approval
  destructive: ['commit', 'push', 'open_pr'],       // Need full approval chain
};

/**
 * Implementation step with policy class annotation
 */
export const ImplementationStep = z.object({
  /** Step order */
  order: z.number(),
  /** Step description */
  description: z.string(),
  /** Tool to invoke */
  tool: z.string(),
  /** Tool arguments */
  args: z.record(z.unknown()),
  /** Policy class for this step */
  policyClass: AgentStepClass,
  /** Files involved */
  files: z.array(z.string()).optional(),
  /** Expected output type */
  expectedOutput: z.enum(['file', 'branch', 'commit', 'pr', 'comment', 'status']).optional(),
  /** Whether this step is reversible */
  reversible: z.boolean().default(true),
});

export type ImplementationStep = z.infer<typeof ImplementationStep>;

/**
 * Full implementation plan generated by agent
 */
export const ImplementationPlan = z.object({
  /** Plan ID */
  id: z.string(),
  /** Associated candidate ID */
  candidateId: z.string(),
  /** Summary of what will be done */
  summary: z.string(),
  /** Detailed steps */
  steps: z.array(ImplementationStep),
  /** Files that will be affected */
  affectedFiles: z.array(z.string()),
  /** Estimated complexity (1-5) */
  complexity: z.number().min(1).max(5),
  /** Risk assessment */
  risk: z.object({
    level: z.enum(['low', 'medium', 'high', 'critical']),
    score: z.number().min(0).max(100),
    factors: z.array(z.object({
      name: z.string(),
      severity: z.number(),
      description: z.string(),
    })),
    mitigations: z.array(z.string()).optional(),
  }),
  /** Required approval scopes (derived from step policy classes) */
  requiredScopes: z.array(z.string()),
  /** Confidence score (0-100) */
  confidence: z.number().min(0).max(100),
  /** Reasoning/explanation */
  reasoning: z.string().optional(),
  /** Generated at timestamp */
  generatedAt: z.string(),
});

export type ImplementationPlan = z.infer<typeof ImplementationPlan>;

// =============================================================================
// Execution Result Types
// =============================================================================

/**
 * Individual step execution result
 */
export const StepExecutionResult = z.object({
  /** Step order */
  order: z.number(),
  /** Whether step succeeded */
  success: z.boolean(),
  /** Output from the step */
  output: z.unknown().optional(),
  /** Error message if failed */
  error: z.string().optional(),
  /** Duration in ms */
  durationMs: z.number().optional(),
  /** Artifacts produced */
  artifacts: z.record(z.string()).optional(),
});

export type StepExecutionResult = z.infer<typeof StepExecutionResult>;

/**
 * Full execution result
 */
export const ExecutionResult = z.object({
  /** Execution ID */
  id: z.string(),
  /** Plan ID that was executed */
  planId: z.string(),
  /** Candidate ID */
  candidateId: z.string(),
  /** Whether execution completed successfully */
  success: z.boolean(),
  /** Step results */
  stepResults: z.array(StepExecutionResult),
  /** Created branch name */
  branchName: z.string().optional(),
  /** Commits created */
  commits: z.array(z.object({
    sha: z.string(),
    message: z.string(),
  })).optional(),
  /** PR URL if created */
  prUrl: z.string().optional(),
  /** PR number if created */
  prNumber: z.number().optional(),
  /** Error message if failed */
  error: z.string().optional(),
  /** Total duration in ms */
  durationMs: z.number(),
  /** Intent receipt for this execution */
  intentReceipt: z.object({
    intent: z.string(),
    changeSummary: z.string(),
    actor: z.string(),
    when: z.string(),
    scope: z.string(),
    policyApproval: z.string(),
    evidence: z.string(),
    traceId: z.string().optional(),
    runId: z.string().optional(),
  }),
  /** Executed at timestamp */
  executedAt: z.string(),
});

export type ExecutionResult = z.infer<typeof ExecutionResult>;

// =============================================================================
// Agent Input Types
// =============================================================================

/**
 * Input for planning phase
 */
export interface PlanInput {
  /** Tenant ID */
  tenantId: string;
  /** Work item to plan for */
  workItem: WorkItem;
  /** Candidate (if exists) */
  candidate?: PRCandidate;
  /** Repository info */
  repo: {
    owner: string;
    name: string;
    fullName: string;
    defaultBranch?: string;
  };
  /** Additional context */
  context?: {
    existingCode?: Record<string, string>;
    relatedPRs?: Array<{ number: number; title: string; status: string }>;
    relatedIssues?: Array<{ number: number; title: string; status: string }>;
  };
  /** Run ID for tracing */
  runId?: string;
}

/**
 * Input for execution phase
 */
export interface ExecuteInput {
  /** Tenant ID */
  tenantId: string;
  /** Plan to execute */
  plan: ImplementationPlan;
  /** Approved scopes */
  approvedScopes: ApprovalScope[];
  /** Patch hash for verification */
  patchHash?: string;
  /** Repository info */
  repo: {
    owner: string;
    name: string;
    fullName: string;
    defaultBranch: string;
  };
  /** Credentials for GitHub operations */
  credentials?: {
    token?: string;
    installationId?: number;
  };
  /** Run ID for tracing */
  runId?: string;
  /** Dry run mode (no actual changes) */
  dryRun?: boolean;
}

// =============================================================================
// Agent Adapter Interface
// =============================================================================

/**
 * Agent adapter interface
 *
 * This interface defines the contract for agents that can:
 * 1. Generate implementation plans from work items
 * 2. Execute plans to create PRs
 *
 * Implementations can be:
 * - StubAgentAdapter: Deterministic output for dev/tests
 * - LocalAgentAdapter: Uses local LLM/model
 * - VertexAgentAdapter: Uses Vertex AI Agent Engine
 * - ExternalAgentAdapter: Calls external API (e.g., bobs-brain pattern)
 */
export interface AgentAdapter {
  /** Adapter name for identification */
  readonly name: string;

  /** Adapter version */
  readonly version: string;

  /**
   * Generate an implementation plan for a work item
   *
   * @param input - Planning input with work item and context
   * @returns Implementation plan with steps and risk assessment
   */
  planCandidate(input: PlanInput): Promise<ImplementationPlan>;

  /**
   * Execute a plan to create a PR
   *
   * @param input - Execution input with plan and approvals
   * @returns Execution result with PR URL or error
   */
  executePlan(input: ExecuteInput): Promise<ExecutionResult>;

  /**
   * Check if the adapter is available/healthy
   */
  healthCheck(): Promise<{ healthy: boolean; message?: string }>;

  /**
   * Get capabilities of this adapter
   */
  getCapabilities(): AgentCapabilities;
}

/**
 * Capabilities exposed by an agent adapter
 */
export interface AgentCapabilities {
  /** Can generate plans */
  canPlan: boolean;
  /** Can execute plans */
  canExecute: boolean;
  /** Supports dry run mode */
  supportsDryRun: boolean;
  /** Supported work item types */
  supportedWorkTypes: string[];
  /** Maximum complexity supported (1-5) */
  maxComplexity: number;
  /** Requires network access */
  requiresNetwork: boolean;
}
