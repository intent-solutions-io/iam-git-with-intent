/**
 * PR Review Automation Service
 *
 * Phase 37: Automated PR review with evidence-based decisions.
 *
 * Features:
 * - Evidence packet analysis
 * - Risk-based review routing
 * - Auto-approve for low-risk changes
 * - PR comment generation
 * - Review decision audit
 *
 * @module @gwi/core/review
 */

import {
  type EvidencePacket,
  type RiskAssessment,
  calculateRiskScore,
} from '../evidence/index.js';
import { createLogger } from '../telemetry/index.js';

const logger = createLogger('review-service');

// =============================================================================
// Types
// =============================================================================

/**
 * Review decision
 */
export interface ReviewDecision {
  /** Decision type */
  decision: 'approve' | 'request_changes' | 'comment';
  /** Whether this was auto-approved */
  autoApproved: boolean;
  /** Reviewer who made the decision (or 'system' for auto) */
  reviewer: string;
  /** Decision timestamp */
  timestamp: Date;
  /** Decision reason */
  reason: string;
  /** Risk assessment that informed the decision */
  risk: RiskAssessment;
  /** Additional conditions that were checked */
  conditions: ReviewCondition[];
}

/**
 * Condition checked during review
 */
export interface ReviewCondition {
  /** Condition identifier */
  id: string;
  /** Human-readable name */
  name: string;
  /** Whether condition passed */
  passed: boolean;
  /** Reason if failed */
  reason?: string;
}

/**
 * Auto-approve configuration
 */
export interface AutoApproveConfig {
  /** Whether auto-approve is enabled */
  enabled: boolean;
  /** Maximum risk score for auto-approve */
  maxRiskScore: number;
  /** Require all tests to pass */
  requirePassingTests: boolean;
  /** Require no security findings */
  requireNoSecurityFindings: boolean;
  /** Require code coverage above threshold */
  minCoveragePercent?: number;
  /** Maximum lines changed for auto-approve */
  maxLinesChanged?: number;
  /** Maximum files changed for auto-approve */
  maxFilesChanged?: number;
  /** Allow auto-approve for maintainers only */
  maintainersOnly?: boolean;
  /** Excluded file patterns (never auto-approve if touched) */
  excludedPatterns?: string[];
}

/**
 * PR comment configuration
 */
export interface CommentConfig {
  /** Include risk summary */
  includeRiskSummary: boolean;
  /** Include test results */
  includeTestResults: boolean;
  /** Include security findings */
  includeSecurityFindings: boolean;
  /** Include file change summary */
  includeFileChanges: boolean;
  /** Include evidence links */
  includeEvidenceLinks: boolean;
  /** Custom header text */
  headerText?: string;
  /** Custom footer text */
  footerText?: string;
}

/**
 * Generated PR comment
 */
export interface PRComment {
  /** Comment body (markdown) */
  body: string;
  /** Whether this is a review comment */
  isReview: boolean;
  /** Review action if applicable */
  reviewAction?: 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT';
}

// =============================================================================
// Default Configurations
// =============================================================================

/**
 * Default auto-approve configuration
 */
export const DEFAULT_AUTO_APPROVE_CONFIG: AutoApproveConfig = {
  enabled: true,
  maxRiskScore: 25,
  requirePassingTests: true,
  requireNoSecurityFindings: true,
  minCoveragePercent: 70,
  maxLinesChanged: 200,
  maxFilesChanged: 10,
  maintainersOnly: false,
  excludedPatterns: [
    '**/package.json',
    '**/package-lock.json',
    '**/*.lock',
    '**/Dockerfile',
    '**/.github/**',
    '**/terraform/**',
  ],
};

/**
 * Default comment configuration
 */
export const DEFAULT_COMMENT_CONFIG: CommentConfig = {
  includeRiskSummary: true,
  includeTestResults: true,
  includeSecurityFindings: true,
  includeFileChanges: true,
  includeEvidenceLinks: true,
  headerText: '## ü§ñ Autopilot Review',
  footerText: '_Generated by Git With Intent_',
};

// =============================================================================
// Review Service
// =============================================================================

/**
 * PR Review Service
 *
 * Handles automated PR review based on evidence analysis.
 */
export class PRReviewService {
  private autoApproveConfig: AutoApproveConfig;
  private commentConfig: CommentConfig;

  constructor(
    autoApproveConfig: Partial<AutoApproveConfig> = {},
    commentConfig: Partial<CommentConfig> = {}
  ) {
    this.autoApproveConfig = { ...DEFAULT_AUTO_APPROVE_CONFIG, ...autoApproveConfig };
    this.commentConfig = { ...DEFAULT_COMMENT_CONFIG, ...commentConfig };
  }

  /**
   * Analyze evidence and make a review decision
   */
  analyzeForReview(packet: EvidencePacket): ReviewDecision {
    const risk = calculateRiskScore(packet);
    const conditions = this.checkAutoApproveConditions(packet, risk);

    const allConditionsPassed = conditions.every(c => c.passed);
    const canAutoApprove = this.autoApproveConfig.enabled && allConditionsPassed;

    let decision: ReviewDecision['decision'];
    let reason: string;

    if (canAutoApprove) {
      decision = 'approve';
      reason = 'All auto-approve conditions met';
    } else if (risk.recommendation === 'block') {
      decision = 'request_changes';
      reason = this.getBlockReason(packet, conditions);
    } else {
      decision = 'comment';
      reason = 'Manual review required';
    }

    const reviewDecision: ReviewDecision = {
      decision,
      autoApproved: canAutoApprove && decision === 'approve',
      reviewer: canAutoApprove ? 'gwi-bot' : 'pending',
      timestamp: new Date(),
      reason,
      risk,
      conditions,
    };

    logger.info('Review decision made', {
      runId: packet.runId,
      decision: reviewDecision.decision,
      autoApproved: reviewDecision.autoApproved,
      riskScore: risk.score,
      riskLevel: risk.level,
    });

    return reviewDecision;
  }

  /**
   * Check all auto-approve conditions
   */
  private checkAutoApproveConditions(
    packet: EvidencePacket,
    risk: RiskAssessment
  ): ReviewCondition[] {
    const conditions: ReviewCondition[] = [];

    // Risk score check
    conditions.push({
      id: 'risk_score',
      name: 'Risk Score',
      passed: risk.score <= this.autoApproveConfig.maxRiskScore,
      reason: risk.score > this.autoApproveConfig.maxRiskScore
        ? `Risk score ${risk.score} exceeds threshold ${this.autoApproveConfig.maxRiskScore}`
        : undefined,
    });

    // Tests passing check
    if (this.autoApproveConfig.requirePassingTests) {
      const allTestsPassing = packet.tests.total === 0 || packet.tests.failed === 0;
      conditions.push({
        id: 'tests_passing',
        name: 'Tests Passing',
        passed: allTestsPassing,
        reason: !allTestsPassing
          ? `${packet.tests.failed} tests failed`
          : undefined,
      });
    }

    // Security findings check
    if (this.autoApproveConfig.requireNoSecurityFindings) {
      const noFindings = packet.security.totalFindings === 0;
      conditions.push({
        id: 'no_security_findings',
        name: 'No Security Findings',
        passed: noFindings,
        reason: !noFindings
          ? `${packet.security.totalFindings} security findings detected`
          : undefined,
      });
    }

    // Coverage check
    if (this.autoApproveConfig.minCoveragePercent !== undefined) {
      const coverageOk = packet.tests.coveragePercent !== undefined &&
        packet.tests.coveragePercent >= this.autoApproveConfig.minCoveragePercent;
      conditions.push({
        id: 'coverage_threshold',
        name: 'Coverage Threshold',
        passed: coverageOk,
        reason: !coverageOk
          ? `Coverage ${packet.tests.coveragePercent ?? 0}% below threshold ${this.autoApproveConfig.minCoveragePercent}%`
          : undefined,
      });
    }

    // Lines changed check
    if (this.autoApproveConfig.maxLinesChanged !== undefined) {
      const linesOk = packet.quality.netLinesChanged <= this.autoApproveConfig.maxLinesChanged;
      conditions.push({
        id: 'lines_changed',
        name: 'Lines Changed',
        passed: linesOk,
        reason: !linesOk
          ? `${packet.quality.netLinesChanged} lines changed exceeds limit ${this.autoApproveConfig.maxLinesChanged}`
          : undefined,
      });
    }

    // Files changed check
    if (this.autoApproveConfig.maxFilesChanged !== undefined) {
      const filesChanged = packet.quality.filesModified + packet.quality.filesAdded;
      const filesOk = filesChanged <= this.autoApproveConfig.maxFilesChanged;
      conditions.push({
        id: 'files_changed',
        name: 'Files Changed',
        passed: filesOk,
        reason: !filesOk
          ? `${filesChanged} files changed exceeds limit ${this.autoApproveConfig.maxFilesChanged}`
          : undefined,
      });
    }

    // Maintainer check
    if (this.autoApproveConfig.maintainersOnly) {
      conditions.push({
        id: 'maintainer_only',
        name: 'Maintainer Only',
        passed: packet.author.isMaintainer,
        reason: !packet.author.isMaintainer
          ? 'Auto-approve restricted to maintainers'
          : undefined,
      });
    }

    // Excluded patterns check
    if (this.autoApproveConfig.excludedPatterns && this.autoApproveConfig.excludedPatterns.length > 0) {
      const touchesExcluded = packet.files.some(f =>
        this.autoApproveConfig.excludedPatterns!.some(pattern =>
          this.matchPattern(f.path, pattern)
        )
      );
      conditions.push({
        id: 'excluded_files',
        name: 'No Excluded Files',
        passed: !touchesExcluded,
        reason: touchesExcluded
          ? 'PR touches files that require manual review'
          : undefined,
      });
    }

    return conditions;
  }

  /**
   * Simple glob pattern matching
   */
  private matchPattern(path: string, pattern: string): boolean {
    // Convert glob pattern to regex step by step
    // First escape regex special chars that aren't glob patterns
    let regexPattern = '';
    for (let i = 0; i < pattern.length; i++) {
      const char = pattern[i];
      const nextChar = pattern[i + 1];

      if (char === '*' && nextChar === '*') {
        regexPattern += '.*';
        i++; // Skip next char
      } else if (char === '*') {
        regexPattern += '[^/]*';
      } else if (char === '?') {
        regexPattern += '.';
      } else if ('.+^${}()|[]\\'.includes(char)) {
        regexPattern += '\\' + char;
      } else {
        regexPattern += char;
      }
    }

    return new RegExp(`^${regexPattern}$`).test(path);
  }

  /**
   * Get reason for blocking
   */
  private getBlockReason(packet: EvidencePacket, conditions: ReviewCondition[]): string {
    const failedConditions = conditions.filter(c => !c.passed);

    if (packet.security.findingsBySeverity.critical > 0) {
      return `Critical security findings detected (${packet.security.findingsBySeverity.critical} critical)`;
    }

    if (failedConditions.length > 0) {
      return failedConditions.map(c => c.reason).filter(Boolean).join('; ');
    }

    return 'Manual review required due to risk assessment';
  }

  /**
   * Generate PR comment from evidence packet
   */
  generateComment(packet: EvidencePacket, decision: ReviewDecision): PRComment {
    const sections: string[] = [];

    // Header
    if (this.commentConfig.headerText) {
      sections.push(this.commentConfig.headerText);
    }

    // Summary line
    sections.push(this.generateSummaryLine(decision));

    // Risk summary
    if (this.commentConfig.includeRiskSummary) {
      sections.push(this.generateRiskSection(decision.risk));
    }

    // Test results
    if (this.commentConfig.includeTestResults) {
      sections.push(this.generateTestSection(packet));
    }

    // Security findings
    if (this.commentConfig.includeSecurityFindings && packet.security.totalFindings > 0) {
      sections.push(this.generateSecuritySection(packet));
    }

    // File changes
    if (this.commentConfig.includeFileChanges && packet.files.length > 0) {
      sections.push(this.generateFileSection(packet));
    }

    // Conditions checked
    if (decision.conditions.length > 0) {
      sections.push(this.generateConditionsSection(decision.conditions));
    }

    // Footer
    if (this.commentConfig.footerText) {
      sections.push('---');
      sections.push(this.commentConfig.footerText);
    }

    return {
      body: sections.join('\n\n'),
      isReview: decision.decision !== 'comment',
      reviewAction: this.mapDecisionToAction(decision.decision),
    };
  }

  /**
   * Generate summary line
   */
  private generateSummaryLine(decision: ReviewDecision): string {
    const emoji = decision.decision === 'approve' ? '‚úÖ' :
      decision.decision === 'request_changes' ? '‚ùå' : 'üëÄ';

    const status = decision.autoApproved
      ? 'Auto-approved'
      : decision.decision === 'approve'
        ? 'Approved'
        : decision.decision === 'request_changes'
          ? 'Changes Requested'
          : 'Review Requested';

    return `${emoji} **${status}** - ${decision.reason}`;
  }

  /**
   * Generate risk section
   */
  private generateRiskSection(risk: RiskAssessment): string {
    const levelEmoji = {
      low: 'üü¢',
      medium: 'üü°',
      high: 'üü†',
      critical: 'üî¥',
    };

    const lines = [
      '### Risk Assessment',
      `${levelEmoji[risk.level]} **Risk Level:** ${risk.level.toUpperCase()} (Score: ${risk.score}/100)`,
      '',
      '<details>',
      '<summary>Risk Factors</summary>',
      '',
      '| Factor | Score |',
      '|--------|-------|',
    ];

    for (const factor of risk.factors) {
      lines.push(`| ${factor.name} | ${factor.score.toFixed(1)} |`);
    }

    lines.push('</details>');

    return lines.join('\n');
  }

  /**
   * Generate test section
   */
  private generateTestSection(packet: EvidencePacket): string {
    const { tests } = packet;
    const emoji = tests.failed > 0 ? '‚ùå' : '‚úÖ';

    const lines = [
      '### Test Results',
      `${emoji} **${tests.passed}/${tests.total}** tests passing`,
    ];

    if (tests.coveragePercent !== undefined) {
      const coverageEmoji = tests.coveragePercent >= 80 ? 'üü¢' :
        tests.coveragePercent >= 60 ? 'üü°' : 'üî¥';
      lines.push(`${coverageEmoji} **Coverage:** ${tests.coveragePercent}%`);

      if (tests.coverageDelta !== undefined) {
        const deltaSign = tests.coverageDelta >= 0 ? '+' : '';
        lines.push(`   (${deltaSign}${tests.coverageDelta}% from base)`);
      }
    }

    if (tests.failedTests && tests.failedTests.length > 0) {
      lines.push('');
      lines.push('**Failed tests:**');
      for (const test of tests.failedTests.slice(0, 5)) {
        lines.push(`- \`${test}\``);
      }
      if (tests.failedTests.length > 5) {
        lines.push(`- _and ${tests.failedTests.length - 5} more..._`);
      }
    }

    return lines.join('\n');
  }

  /**
   * Generate security section
   */
  private generateSecuritySection(packet: EvidencePacket): string {
    const { security } = packet;

    const lines = [
      '### Security Findings',
      `‚ö†Ô∏è **${security.totalFindings}** security finding(s) detected`,
      '',
    ];

    const severityOrder: Array<keyof typeof security.findingsBySeverity> = [
      'critical', 'high', 'medium', 'low', 'info'
    ];

    for (const severity of severityOrder) {
      const count = security.findingsBySeverity[severity];
      if (count > 0) {
        const emoji = severity === 'critical' ? 'üî¥' :
          severity === 'high' ? 'üü†' :
            severity === 'medium' ? 'üü°' :
              severity === 'low' ? 'üü¢' : '‚ö™';
        lines.push(`${emoji} ${severity.toUpperCase()}: ${count}`);
      }
    }

    if (security.topFindings.length > 0) {
      lines.push('');
      lines.push('<details>');
      lines.push('<summary>Top Findings</summary>');
      lines.push('');

      for (const finding of security.topFindings.slice(0, 3)) {
        lines.push(`- **${finding.title}** (${finding.severity})`);
        if (finding.file) {
          lines.push(`  - File: \`${finding.file}${finding.line ? `:${finding.line}` : ''}\``);
        }
        if (finding.cwe) {
          lines.push(`  - CWE: ${finding.cwe}`);
        }
      }

      lines.push('</details>');
    }

    return lines.join('\n');
  }

  /**
   * Generate file changes section
   */
  private generateFileSection(packet: EvidencePacket): string {
    const lines = [
      '### File Changes',
      `üìÅ **${packet.quality.filesModified + packet.quality.filesAdded}** files changed ` +
      `(+${packet.quality.linesAdded} / -${packet.quality.linesRemoved})`,
      '',
      '<details>',
      '<summary>Files</summary>',
      '',
      '| File | Changes |',
      '|------|---------|',
    ];

    for (const file of packet.files.slice(0, 20)) {
      const typeIcon = file.type === 'added' ? 'üÜï' :
        file.type === 'deleted' ? 'üóëÔ∏è' :
          file.type === 'renamed' ? 'üìù' : '‚úèÔ∏è';
      lines.push(`| ${typeIcon} \`${file.path}\` | +${file.linesAdded}/-${file.linesRemoved} |`);
    }

    if (packet.files.length > 20) {
      lines.push(`| _...and ${packet.files.length - 20} more files_ | |`);
    }

    lines.push('</details>');

    return lines.join('\n');
  }

  /**
   * Generate conditions section
   */
  private generateConditionsSection(conditions: ReviewCondition[]): string {
    const lines = [
      '### Review Conditions',
      '',
    ];

    for (const condition of conditions) {
      const emoji = condition.passed ? '‚úÖ' : '‚ùå';
      const status = condition.passed ? 'Passed' : 'Failed';
      lines.push(`${emoji} **${condition.name}**: ${status}`);
      if (!condition.passed && condition.reason) {
        lines.push(`   - ${condition.reason}`);
      }
    }

    return lines.join('\n');
  }

  /**
   * Map decision to GitHub review action
   */
  private mapDecisionToAction(decision: ReviewDecision['decision']): PRComment['reviewAction'] {
    switch (decision) {
      case 'approve':
        return 'APPROVE';
      case 'request_changes':
        return 'REQUEST_CHANGES';
      default:
        return 'COMMENT';
    }
  }
}

// =============================================================================
// Review Audit
// =============================================================================

/**
 * Review audit entry
 */
export interface ReviewAuditEntry {
  /** Entry ID */
  id: string;
  /** Run ID */
  runId: string;
  /** Tenant ID */
  tenantId: string;
  /** PR number */
  prNumber: number;
  /** Repository */
  repo: string;
  /** Decision made */
  decision: ReviewDecision;
  /** Timestamp */
  timestamp: Date;
  /** Evidence packet reference */
  evidenceRef?: string;
}

/**
 * Review audit logger
 */
export function logReviewDecision(
  runId: string,
  tenantId: string,
  prNumber: number,
  repo: string,
  decision: ReviewDecision
): ReviewAuditEntry {
  const entry: ReviewAuditEntry = {
    id: `review-${runId}-${Date.now()}`,
    runId,
    tenantId,
    prNumber,
    repo,
    decision,
    timestamp: new Date(),
  };

  logger.info('Review decision logged', {
    id: entry.id,
    runId,
    tenantId,
    prNumber,
    repo,
    decision: decision.decision,
    autoApproved: decision.autoApproved,
    riskScore: decision.risk.score,
  });

  return entry;
}

// =============================================================================
// Exports
// =============================================================================

export {
  PRReviewService as ReviewService,
};
