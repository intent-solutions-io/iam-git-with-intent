/**
 * Phase 26: LLM Planner Types
 *
 * Type definitions for the PatchPlan contract used by the LLM Planner.
 * All plans generated by Gemini/Claude must conform to PatchPlanSchema.
 */

import { z } from 'zod';

// =============================================================================
// Provider Configuration
// =============================================================================

/**
 * Supported LLM providers for planning
 */
export const PlannerProvider = z.enum(['gemini', 'claude']);
export type PlannerProvider = z.infer<typeof PlannerProvider>;

/**
 * Risk level for plan/step assessment
 */
export const PatchRiskLevel = z.enum(['low', 'medium', 'high', 'critical']);
export type PatchRiskLevel = z.infer<typeof PatchRiskLevel>;

// =============================================================================
// Security Rules - Path Validation
// =============================================================================

/**
 * Safe file path - prevents path traversal attacks
 * - No absolute paths (starting with /)
 * - No parent directory traversal (..)
 * - No null bytes
 * - Must be non-empty
 */
export const SafeFilePath = z
  .string()
  .min(1, 'Path cannot be empty')
  .refine((path) => !path.startsWith('/'), {
    message: 'Absolute paths are not allowed',
  })
  .refine((path) => !path.includes('..'), {
    message: 'Path traversal (..) is not allowed',
  })
  .refine((path) => !path.includes('\0'), {
    message: 'Null bytes are not allowed in paths',
  })
  .refine((path) => !/^[a-zA-Z]:/.test(path), {
    message: 'Windows absolute paths are not allowed',
  });

export type SafeFilePath = z.infer<typeof SafeFilePath>;

// =============================================================================
// File Entry
// =============================================================================

/**
 * File action type for a planned change
 */
export const PatchFileAction = z.enum([
  'create', // Create new file
  'modify', // Modify existing file
  'delete', // Delete file
  'rename', // Rename file (old_path required)
]);
export type PatchFileAction = z.infer<typeof PatchFileAction>;

/**
 * Single file entry in the patch plan
 */
export const PatchFileEntry = z.object({
  /** Relative path to file (safe, no traversal) */
  path: SafeFilePath,
  /** Action to perform */
  action: PatchFileAction,
  /** Human-readable reason for this change */
  reason: z.string().min(1),
  /** Old path for rename actions */
  old_path: SafeFilePath.optional(),
  /** Language/type hint (e.g., "typescript", "json") */
  language: z.string().optional(),
  /** Estimated lines changed */
  estimated_lines: z.number().int().min(0).optional(),
});

export type PatchFileEntry = z.infer<typeof PatchFileEntry>;

// =============================================================================
// Step Entry
// =============================================================================

/**
 * Single step in the execution plan
 */
export const PatchStepEntry = z.object({
  /** Step order (1-indexed) */
  order: z.number().int().min(1),
  /** Step name/title */
  name: z.string().min(1),
  /** What this step accomplishes */
  description: z.string().min(1),
  /** Files affected by this step */
  files: z.array(SafeFilePath).min(1),
  /** Prompt/instructions for the coder agent */
  prompt: z.string().min(1),
  /** Whether this step can run in parallel with others */
  parallelizable: z.boolean().default(false),
  /** Dependencies on other steps (by order number) */
  depends_on: z.array(z.number().int().min(1)).default([]),
  /** Risk level for this specific step */
  risk: PatchRiskLevel.default('low'),
});

export type PatchStepEntry = z.infer<typeof PatchStepEntry>;

// =============================================================================
// Test Entry
// =============================================================================

/**
 * Test type classification
 */
export const TestType = z.enum(['unit', 'integration', 'e2e', 'smoke', 'manual']);
export type TestType = z.infer<typeof TestType>;

/**
 * Test to validate the plan execution
 */
export const PatchTestEntry = z.object({
  /** Test name/description */
  name: z.string().min(1),
  /** Test type */
  type: TestType,
  /** Command to run the test (or manual instructions) */
  command: z.string().min(1),
  /** Files this test validates */
  validates: z.array(SafeFilePath).optional(),
  /** Expected to pass before plan execution */
  must_pass_before: z.boolean().default(false),
  /** Expected to pass after plan execution */
  must_pass_after: z.boolean().default(true),
});

export type PatchTestEntry = z.infer<typeof PatchTestEntry>;

// =============================================================================
// Risk Assessment
// =============================================================================

/**
 * Risk mitigation strategy
 */
export const RiskMitigation = z.object({
  /** Risk identifier */
  id: z.string().min(1),
  /** Risk severity */
  severity: PatchRiskLevel,
  /** What the risk is */
  description: z.string().min(1),
  /** How to mitigate it */
  mitigation: z.string().min(1),
  /** Files affected by this risk */
  affected_files: z.array(SafeFilePath).optional(),
  /** Whether human review is required */
  requires_review: z.boolean().default(false),
});

export type RiskMitigation = z.infer<typeof RiskMitigation>;

/**
 * Complete risk assessment for the plan
 */
export const PatchRiskAssessment = z.object({
  /** Overall risk level */
  overall: PatchRiskLevel,
  /** Confidence in risk assessment (0-100) */
  confidence: z.number().min(0).max(100),
  /** Individual risks identified */
  risks: z.array(RiskMitigation),
  /** Whether plan requires human approval */
  requires_approval: z.boolean(),
  /** Reasons human review is needed */
  review_reasons: z.array(z.string()).optional(),
});

export type PatchRiskAssessment = z.infer<typeof PatchRiskAssessment>;

// =============================================================================
// Policy Context (Phase 25 Integration)
// =============================================================================

/**
 * Policy evaluation result to include in plan
 */
export const PlanPolicyContext = z.object({
  /** Whether policy allows execution */
  allowed: z.boolean(),
  /** Policy that was evaluated */
  policy_name: z.string().optional(),
  /** Scopes required for this plan */
  required_scopes: z.array(z.string()).optional(),
  /** Approval IDs already present */
  approval_ids: z.array(z.string()).optional(),
  /** Policy evaluation notes */
  notes: z.string().optional(),
});

export type PlanPolicyContext = z.infer<typeof PlanPolicyContext>;

// =============================================================================
// Rollback Plan
// =============================================================================

/**
 * Rollback instructions if plan execution fails
 */
export const RollbackPlan = z.object({
  /** Whether automatic rollback is supported */
  automatic: z.boolean(),
  /** Steps to rollback (in reverse order) */
  steps: z.array(z.string()).min(1),
  /** Git commit to rollback to (if known) */
  rollback_commit: z.string().optional(),
  /** Estimated time to rollback in seconds */
  estimated_time_sec: z.number().int().min(0).optional(),
});

export type RollbackPlan = z.infer<typeof RollbackPlan>;

// =============================================================================
// PatchPlan - Main Contract
// =============================================================================

/**
 * Complete PatchPlan contract
 *
 * This is the main schema that LLM planners must produce.
 * It includes all information needed to:
 * 1. Understand what changes will be made
 * 2. Execute the changes via coder agents
 * 3. Validate the changes via tests
 * 4. Rollback if something goes wrong
 * 5. Audit the plan creation and execution
 */
export const PatchPlanSchema = z.object({
  // =========================================================================
  // Identity & Tracing
  // =========================================================================

  /** Unique plan identifier (UUID) */
  plan_id: z.string().uuid(),

  /** Plan creation timestamp (ISO 8601) */
  created_at: z.string().datetime(),

  /** LLM provider that generated this plan */
  provider: PlannerProvider,

  /** Specific model used (e.g., "gemini-2.0-flash", "claude-3-sonnet") */
  model: z.string().min(1),

  /** Trace ID for distributed tracing (Phase 23 integration) */
  trace_id: z.string().optional(),

  /** Request ID for correlation */
  request_id: z.string().optional(),

  // =========================================================================
  // Plan Content
  // =========================================================================

  /** Schema version for forward compatibility */
  version: z.literal(1),

  /** Human-readable summary of what this plan accomplishes */
  intent_summary: z.string().min(10),

  /** Files that will be affected */
  files: z.array(PatchFileEntry).min(1),

  /** Execution steps in order */
  steps: z.array(PatchStepEntry).min(1),

  /** Tests to validate the changes */
  tests: z.array(PatchTestEntry),

  // =========================================================================
  // Risk & Policy
  // =========================================================================

  /** Risk assessment for the plan */
  risk: PatchRiskAssessment,

  /** Policy evaluation context (Phase 25) */
  policy: PlanPolicyContext,

  /** Rollback plan if execution fails */
  rollback: RollbackPlan,

  // =========================================================================
  // Acceptance & Metadata
  // =========================================================================

  /** Criteria for plan success */
  acceptance_criteria: z.array(z.string()).min(1),

  /** Total estimated execution time in seconds */
  estimated_duration_sec: z.number().int().min(0).optional(),

  /** Source context (PR URL, issue URL, etc.) */
  source_url: z.string().url().optional(),

  /** Hash of the input intent for deduplication */
  intent_hash: z.string().optional(),

  /** Tenant ID for multi-tenant systems */
  tenant_id: z.string().optional(),
});

export type PatchPlan = z.infer<typeof PatchPlanSchema>;

// =============================================================================
// Validation Helpers
// =============================================================================

/**
 * Validation result structure
 */
export interface PatchPlanValidationResult {
  valid: boolean;
  errors?: z.ZodError;
  errorMessages?: string[];
}

/**
 * Validate a PatchPlan, returning structured errors
 */
export function validatePatchPlan(data: unknown): PatchPlanValidationResult {
  const result = PatchPlanSchema.safeParse(data);
  if (result.success) {
    return { valid: true };
  }
  return {
    valid: false,
    errors: result.error,
    errorMessages: result.error.errors.map(
      (e) => `${e.path.join('.')}: ${e.message}`
    ),
  };
}

/**
 * Parse and validate a PatchPlan, throwing on error
 */
export function parsePatchPlan(data: unknown): PatchPlan {
  return PatchPlanSchema.parse(data);
}

/**
 * Safely parse a PatchPlan, returning null on error
 */
export function safeParsePatchPlan(data: unknown): PatchPlan | null {
  const result = PatchPlanSchema.safeParse(data);
  return result.success ? result.data : null;
}

// =============================================================================
// Security Validation
// =============================================================================

/**
 * Security validation errors
 */
export interface SecurityValidationResult {
  secure: boolean;
  violations: string[];
}

/**
 * Additional security checks beyond schema validation
 * - Checks for suspicious patterns in file paths
 * - Validates no shell injection in commands
 * - Ensures no secrets in prompts
 */
export function validatePatchPlanSecurity(
  plan: PatchPlan
): SecurityValidationResult {
  const violations: string[] = [];

  // Check file paths for suspicious patterns
  const suspiciousPatterns = [
    /\$\{.*\}/, // Variable interpolation
    /`.*`/, // Backtick execution
    /\$\(.*\)/, // Command substitution
    /;\s*(rm|del|rmdir|format)/, // Chained destructive commands
    /\|\s*(sh|bash|cmd|powershell)/, // Pipe to shell
  ];

  for (const file of plan.files) {
    for (const pattern of suspiciousPatterns) {
      if (pattern.test(file.path)) {
        violations.push(`Suspicious pattern in file path: ${file.path}`);
      }
    }
  }

  // Check test commands for shell injection
  const dangerousCommands = [
    /;\s*rm\s+-rf/i, // rm -rf
    /&&\s*curl.*\|.*sh/i, // curl pipe to shell
    />\s*\/etc\//i, // Writing to /etc
    />\s*\/dev\//i, // Writing to /dev
  ];

  for (const test of plan.tests) {
    for (const pattern of dangerousCommands) {
      if (pattern.test(test.command)) {
        violations.push(`Dangerous command in test: ${test.name}`);
      }
    }
  }

  // Check prompts don't contain obvious secrets
  const secretPatterns = [
    /sk-[a-zA-Z0-9]{20,}/, // API keys
    /ghp_[a-zA-Z0-9]{36}/, // GitHub tokens
    /password\s*[:=]\s*['"][^'"]+['"]/i, // Hardcoded passwords
  ];

  for (const step of plan.steps) {
    for (const pattern of secretPatterns) {
      if (pattern.test(step.prompt)) {
        violations.push(`Potential secret in step prompt: ${step.name}`);
      }
    }
  }

  return {
    secure: violations.length === 0,
    violations,
  };
}
