name: Auto-Fix

on:
  issues:
    types: [labeled]

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write  # Required for WIF

env:
  PROJECT_ID: ${{ vars.GCP_PROJECT_ID }}
  REGION: us-central1
  NODE_VERSION: '20'
  DB_PATH: /tmp/gwi-autofix.db

jobs:
  # =============================================================================
  # Auto-Fix Execution
  # =============================================================================

  auto-fix:
    name: Auto-Fix Issue
    runs-on: ubuntu-latest
    if: |
      contains(github.event.label.name, 'auto-fix') ||
      contains(github.event.label.name, 'gwi:auto') ||
      contains(github.event.label.name, 'gwi-auto-code')

    steps:
      # -----------------------------------------------------------------------
      # Setup
      # -----------------------------------------------------------------------

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better context

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build project
        run: npm run build

      # -----------------------------------------------------------------------
      # Authentication (WIF for GCP if needed)
      # -----------------------------------------------------------------------

      - name: Authenticate to GCP (WIF)
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ vars.WIF_PROVIDER }}
          service_account: ${{ vars.WIF_SERVICE_ACCOUNT }}
        continue-on-error: true  # Optional - only needed if using GCP services

      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2
        continue-on-error: true

      # -----------------------------------------------------------------------
      # Database Setup
      # -----------------------------------------------------------------------

      - name: Initialize SQLite Database
        run: |
          echo "Initializing SQLite database at ${{ env.DB_PATH }}"

          # Create database directory
          mkdir -p $(dirname "${{ env.DB_PATH }}")

          # Initialize schema
          sqlite3 "${{ env.DB_PATH }}" < db/schema.sql

          # Verify schema
          echo "Database initialized. Tables:"
          sqlite3 "${{ env.DB_PATH }}" ".tables"

      # -----------------------------------------------------------------------
      # Run Auto-Fix
      # -----------------------------------------------------------------------

      - name: Run Auto-Fix
        id: autofix
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          GOOGLE_AI_API_KEY: ${{ secrets.GOOGLE_AI_API_KEY }}
          GWI_STORE_BACKEND: memory
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_URL: ${{ github.event.issue.html_url }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          set +e  # Don't exit on error - we want to capture results

          echo "============================================"
          echo "Auto-Fix Starting"
          echo "============================================"
          echo "Issue: #${{ github.event.issue.number }}"
          echo "Repository: ${{ github.repository }}"
          echo "Triggered by: ${{ github.event.sender.login }}"
          echo "============================================"

          # Record start time
          START_TIME=$(date +%s%3N)

          # Generate run ID
          RUN_ID=$(uuidgen)
          echo "run_id=$RUN_ID" >> $GITHUB_OUTPUT
          echo "start_time=$START_TIME" >> $GITHUB_OUTPUT

          # Run gwi issue-to-code
          node apps/cli/dist/index.js issue-to-code "$ISSUE_URL" \
            --auto-approve \
            --run-id "$RUN_ID" \
            2>&1 | tee /tmp/autofix-output.log

          # Capture exit code
          EXIT_CODE=${PIPESTATUS[0]}
          echo "exit_code=$EXIT_CODE" >> $GITHUB_OUTPUT

          # Record end time
          END_TIME=$(date +%s%3N)
          DURATION=$((END_TIME - START_TIME))
          echo "duration_ms=$DURATION" >> $GITHUB_OUTPUT

          # Determine status
          if [ $EXIT_CODE -eq 0 ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi

          echo "============================================"
          echo "Auto-Fix Completed"
          echo "Status: $([ $EXIT_CODE -eq 0 ] && echo 'SUCCESS' || echo 'FAILURE')"
          echo "Duration: ${DURATION}ms"
          echo "============================================"

          exit 0  # Always exit 0 so we can process results

      # -----------------------------------------------------------------------
      # Parse Results and Extract Metrics
      # -----------------------------------------------------------------------

      - name: Parse Auto-Fix Results
        id: parse
        run: |
          # Extract PR URL from output
          PR_URL=$(grep -oP 'PR created: \K(https://[^\s]+)' /tmp/autofix-output.log || echo "")
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT

          # Extract PR number from URL
          if [ -n "$PR_URL" ]; then
            PR_NUMBER=$(echo "$PR_URL" | grep -oP 'pull/\K\d+' || echo "")
            echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          fi

          # Extract file counts
          FILES_CHANGED=$(grep -oP 'Files changed: \K\d+' /tmp/autofix-output.log || echo "0")
          echo "files_changed=$FILES_CHANGED" >> $GITHUB_OUTPUT

          # Extract line counts
          LINES_ADDED=$(grep -oP 'Lines added: \K\d+' /tmp/autofix-output.log || echo "0")
          LINES_DELETED=$(grep -oP 'Lines deleted: \K\d+' /tmp/autofix-output.log || echo "0")
          echo "lines_added=$LINES_ADDED" >> $GITHUB_OUTPUT
          echo "lines_deleted=$LINES_DELETED" >> $GITHUB_OUTPUT

          # Extract error message if failed
          if [ "${{ steps.autofix.outputs.status }}" = "failure" ]; then
            ERROR_MSG=$(tail -50 /tmp/autofix-output.log | grep -oP 'Error: \K.*' | head -1 || echo "Unknown error")
            echo "error_message=$ERROR_MSG" >> $GITHUB_OUTPUT
          fi

      # -----------------------------------------------------------------------
      # Store Run Data in SQLite
      # -----------------------------------------------------------------------

      - name: Store Run Metadata
        run: |
          sqlite3 "${{ env.DB_PATH }}" <<EOF
          INSERT INTO autofix_runs (
            id,
            issue_number,
            pr_number,
            pr_url,
            repo_owner,
            repo_name,
            status,
            created_at,
            started_at,
            completed_at,
            duration_ms,
            trigger_source,
            triggered_by,
            agent_version,
            files_changed,
            lines_added,
            lines_deleted,
            commits_created,
            merged,
            human_edits_required,
            error_message
          ) VALUES (
            '${{ steps.autofix.outputs.run_id }}',
            ${{ github.event.issue.number }},
            $([ -n "${{ steps.parse.outputs.pr_number }}" ] && echo "${{ steps.parse.outputs.pr_number }}" || echo "NULL"),
            $([ -n "${{ steps.parse.outputs.pr_url }}" ] && echo "'${{ steps.parse.outputs.pr_url }}'" || echo "NULL"),
            '${{ github.repository_owner }}',
            '${{ github.event.repository.name }}',
            '${{ steps.autofix.outputs.status }}',
            datetime('now'),
            datetime('now', '-${{ steps.autofix.outputs.duration_ms }}' || ' milliseconds'),
            datetime('now'),
            ${{ steps.autofix.outputs.duration_ms }},
            'issue_label',
            '${{ github.event.sender.login }}',
            'v0.2.0',
            ${{ steps.parse.outputs.files_changed }},
            ${{ steps.parse.outputs.lines_added }},
            ${{ steps.parse.outputs.lines_deleted }},
            1,
            0,
            0,
            $([ -n "${{ steps.parse.outputs.error_message }}" ] && echo "'${{ steps.parse.outputs.error_message }}'" || echo "NULL")
          );
          EOF

          echo "Run metadata stored in database"

      # -----------------------------------------------------------------------
      # Run Quality Checks (if PR was created)
      # -----------------------------------------------------------------------

      - name: Run Quality Checks
        id: quality
        if: steps.parse.outputs.pr_url != ''
        run: |
          echo "Running quality checks..."

          # Lint
          npm run lint 2>&1 | tee /tmp/lint-output.log
          LINT_EXIT=$?
          echo "lint_passed=$([ $LINT_EXIT -eq 0 ] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT

          # Type check
          npm run typecheck 2>&1 | tee /tmp/typecheck-output.log
          TYPECHECK_EXIT=$?
          echo "typecheck_passed=$([ $TYPECHECK_EXIT -eq 0 ] && echo 'true' || echo 'false')" >> $GITHUB_OUTPUT

          # Tests
          npm run test 2>&1 | tee /tmp/test-output.log
          TEST_EXIT=$?

          # Extract test counts
          TESTS_RUN=$(grep -oP '\d+(?= tests?)' /tmp/test-output.log | head -1 || echo "0")
          TESTS_PASSED=$(grep -oP '\d+(?= passed)' /tmp/test-output.log | head -1 || echo "0")
          TESTS_FAILED=$(grep -oP '\d+(?= failed)' /tmp/test-output.log | head -1 || echo "0")

          echo "tests_run=$TESTS_RUN" >> $GITHUB_OUTPUT
          echo "tests_passed=$TESTS_PASSED" >> $GITHUB_OUTPUT
          echo "tests_failed=$TESTS_FAILED" >> $GITHUB_OUTPUT

          exit 0  # Don't fail workflow on quality check failures

      # -----------------------------------------------------------------------
      # Store Quality Metrics
      # -----------------------------------------------------------------------

      - name: Store Quality Metrics
        if: steps.parse.outputs.pr_url != ''
        run: |
          sqlite3 "${{ env.DB_PATH }}" <<EOF
          INSERT INTO quality_metrics (
            run_id,
            lint_passed,
            lint_errors,
            typecheck_passed,
            typecheck_errors,
            tests_run,
            tests_passed,
            tests_failed,
            coverage_before,
            coverage_after,
            coverage_delta,
            measured_at
          ) VALUES (
            '${{ steps.autofix.outputs.run_id }}',
            $([ "${{ steps.quality.outputs.lint_passed }}" = "true" ] && echo "1" || echo "0"),
            0,
            $([ "${{ steps.quality.outputs.typecheck_passed }}" = "true" ] && echo "1" || echo "0"),
            0,
            ${{ steps.quality.outputs.tests_run }},
            ${{ steps.quality.outputs.tests_passed }},
            ${{ steps.quality.outputs.tests_failed }},
            0,
            0,
            0,
            datetime('now')
          );
          EOF

          echo "Quality metrics stored in database"

      # -----------------------------------------------------------------------
      # Grade the Fix
      # -----------------------------------------------------------------------

      - name: Grade Auto-Fix Quality
        id: grade
        if: steps.parse.outputs.pr_url != ''
        env:
          GOOGLE_AI_API_KEY: ${{ secrets.GOOGLE_AI_API_KEY }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
        run: |
          # Extract commit message and diff for AI analysis
          COMMIT_MSG=$(git log -1 --pretty=%B HEAD 2>/dev/null || echo "Auto-fix commit")
          DIFF_CONTENT=$(git diff HEAD~1 2>/dev/null || echo "")

          # Use Node.js to grade the fix with AI assistance
          node -e "
          const { AutoFixGradingService } = require('./packages/core/dist/monitoring/auto-fix-grading.js');

          const run = {
            id: '${{ steps.autofix.outputs.run_id }}',
            prUrl: '${{ steps.parse.outputs.pr_url }}',
            status: '${{ steps.autofix.outputs.status }}',
            lintPassed: ${{ steps.quality.outputs.lint_passed }},
            typecheckPassed: ${{ steps.quality.outputs.typecheck_passed }},
            complexityDelta: 0,
            filesChanged: ${{ steps.parse.outputs.files_changed }},
            linesAdded: ${{ steps.parse.outputs.lines_added }},
            linesDeleted: ${{ steps.parse.outputs.lines_deleted }},
            testsRun: ${{ steps.quality.outputs.tests_run }},
            testsPassed: ${{ steps.quality.outputs.tests_passed }},
            testsFailed: ${{ steps.quality.outputs.tests_failed }},
            coverageBefore: 0,
            coverageAfter: 0,
            merged: false,
            humanEditsRequired: false,
            commentsReceived: 0,
            tokensUsed: 0,
            apiCost: 0,
            durationMs: ${{ steps.autofix.outputs.duration_ms }},
            commitMessage: process.env.COMMIT_MSG || '',
            diffContent: process.env.DIFF_CONTENT || '',
            readmeUpdated: false,
            commentsAdded: 0,
            docsChanged: false
          };

          // Initialize grading service with Gemini provider
          const service = new AutoFixGradingService({
            aiProvider: 'gemini',
            useAI: true
          });

          // Grade with AI assistance (falls back to rules if no API key)
          service.grade(run, true).then(grade => {
            console.log('letter_grade=' + grade.letterGrade);
            console.log('overall_score=' + Math.round(grade.overallScore));
            console.log('summary=' + grade.summary.replace(/'/g, ''));

            // Extract top strengths and weaknesses
            const strengths = grade.strengths.slice(0, 3).join('; ').replace(/'/g, '');
            const weaknesses = grade.weaknesses.slice(0, 3).join('; ').replace(/'/g, '');

            console.log('strengths=' + (strengths || 'None identified'));
            console.log('weaknesses=' + (weaknesses || 'None identified'));
          }).catch(err => {
            console.error('Grading failed:', err);
            process.exit(1);
          });
          " >> $GITHUB_OUTPUT

          cat $GITHUB_OUTPUT

      # -----------------------------------------------------------------------
      # Store Grade
      # -----------------------------------------------------------------------

      - name: Store Grade
        if: steps.parse.outputs.pr_url != ''
        run: |
          sqlite3 "${{ env.DB_PATH }}" <<EOF
          INSERT INTO grades (
            run_id,
            letter_grade,
            overall_score,
            code_quality_score,
            test_coverage_score,
            pr_outcome_score,
            cost_efficiency_score,
            documentation_score,
            summary,
            graded_at
          ) VALUES (
            '${{ steps.autofix.outputs.run_id }}',
            '${{ steps.grade.outputs.letter_grade }}',
            ${{ steps.grade.outputs.overall_score }},
            0,
            0,
            0,
            0,
            0,
            '${{ steps.grade.outputs.summary }}',
            datetime('now')
          );
          EOF

          echo "Grade stored in database"

      # -----------------------------------------------------------------------
      # Post Results to Issue
      # -----------------------------------------------------------------------

      - name: Post Success Comment
        if: steps.autofix.outputs.status == 'success' && steps.parse.outputs.pr_url != ''
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Build comment body
            const body = `## ✅ Auto-Fix Successful

            **Run ID:** \`${{ steps.autofix.outputs.run_id }}\`
            **Duration:** ${{ steps.autofix.outputs.duration_ms }}ms
            **PR Created:** ${{ steps.parse.outputs.pr_url }}

            ### Changes
            - **Files Changed:** ${{ steps.parse.outputs.files_changed }}
            - **Lines Added:** ${{ steps.parse.outputs.lines_added }}
            - **Lines Deleted:** ${{ steps.parse.outputs.lines_deleted }}

            ### Quality Metrics
            - **Lint:** ${{ steps.quality.outputs.lint_passed == 'true' && '✅ Passed' || '❌ Failed' }}
            - **Type Check:** ${{ steps.quality.outputs.typecheck_passed == 'true' && '✅ Passed' || '❌ Failed' }}
            - **Tests:** ${{ steps.quality.outputs.tests_passed }}/${{ steps.quality.outputs.tests_run }} passed

            ### Grade
            **${{ steps.grade.outputs.letter_grade }}** (${{ steps.grade.outputs.overall_score }}/100)

            ${{ steps.grade.outputs.summary }}

            ---
            *Generated by [Git With Intent](https://github.com/intent-solutions-io/git-with-intent) Auto-Fix System*`;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      - name: Post Failure Comment
        if: steps.autofix.outputs.status == 'failure'
        uses: actions/github-script@v7
        with:
          script: |
            const body = `## ❌ Auto-Fix Failed

            **Run ID:** \`${{ steps.autofix.outputs.run_id }}\`
            **Duration:** ${{ steps.autofix.outputs.duration_ms }}ms

            ### Error
            \`\`\`
            ${{ steps.parse.outputs.error_message }}
            \`\`\`

            ### Logs
            Please check the [workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) for detailed logs.

            ---
            *Generated by [Git With Intent](https://github.com/intent-solutions-io/git-with-intent) Auto-Fix System*`;

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      # -----------------------------------------------------------------------
      # Store Alert
      # -----------------------------------------------------------------------

      - name: Store Alert
        if: always()
        run: |
          ALERT_TYPE=$([ "${{ steps.autofix.outputs.status }}" = "success" ] && echo "success" || echo "error")
          SEVERITY=$([ "${{ steps.autofix.outputs.status }}" = "success" ] && echo "low" || echo "high")
          TITLE=$([ "${{ steps.autofix.outputs.status }}" = "success" ] && echo "Auto-Fix Successful" || echo "Auto-Fix Failed")
          MESSAGE=$([ "${{ steps.autofix.outputs.status }}" = "success" ] && echo "PR created successfully" || echo "${{ steps.parse.outputs.error_message }}")

          sqlite3 "${{ env.DB_PATH }}" <<EOF
          INSERT INTO alerts (
            run_id,
            type,
            severity,
            title,
            message,
            sent,
            sent_via,
            created_at
          ) VALUES (
            '${{ steps.autofix.outputs.run_id }}',
            '$ALERT_TYPE',
            '$SEVERITY',
            '$TITLE',
            '$MESSAGE',
            1,
            'github_comment',
            datetime('now')
          );
          EOF

      # -----------------------------------------------------------------------
      # Upload Database Artifact
      # -----------------------------------------------------------------------

      - name: Upload Database Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: autofix-database-${{ github.run_id }}
          path: ${{ env.DB_PATH }}
          retention-days: 30

      # -----------------------------------------------------------------------
      # Analytics Report
      # -----------------------------------------------------------------------

      - name: Generate Analytics Report
        if: always()
        run: |
          echo "============================================"
          echo "Analytics Summary"
          echo "============================================"

          sqlite3 "${{ env.DB_PATH }}" <<EOF
          SELECT 'Total Runs: ' || COUNT(*) FROM autofix_runs;
          SELECT 'Success Rate: ' || ROUND(100.0 * SUM(CASE WHEN status = 'success' THEN 1 ELSE 0 END) / COUNT(*), 2) || '%' FROM autofix_runs;
          SELECT 'Average Duration: ' || ROUND(AVG(duration_ms), 0) || 'ms' FROM autofix_runs;
          EOF

          echo "============================================"

      # -----------------------------------------------------------------------
      # Security Scan (Optional)
      # -----------------------------------------------------------------------

      - name: Security Scan Generated Code
        if: steps.parse.outputs.pr_url != ''
        continue-on-error: true
        run: |
          echo "Running security scan on generated code..."

          # Check for secrets in diff
          if git diff HEAD~1 | grep -i "api[_-]key\|secret\|password\|token" > /dev/null; then
            echo "⚠️  Warning: Potential secrets detected in generated code"
          else
            echo "✅ No obvious secrets detected"
          fi

      # -----------------------------------------------------------------------
      # Final Summary
      # -----------------------------------------------------------------------

      - name: Job Summary
        if: always()
        run: |
          echo "## Auto-Fix Run Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Run ID:** \`${{ steps.autofix.outputs.run_id }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ steps.autofix.outputs.status }}" >> $GITHUB_STEP_SUMMARY
          echo "**Duration:** ${{ steps.autofix.outputs.duration_ms }}ms" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.autofix.outputs.status }}" = "success" ]; then
            echo "**PR:** ${{ steps.parse.outputs.pr_url }}" >> $GITHUB_STEP_SUMMARY
            echo "**Grade:** ${{ steps.grade.outputs.letter_grade }} (${{ steps.grade.outputs.overall_score }}/100)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Quality Metrics" >> $GITHUB_STEP_SUMMARY
            echo "- Lint: ${{ steps.quality.outputs.lint_passed }}" >> $GITHUB_STEP_SUMMARY
            echo "- Type Check: ${{ steps.quality.outputs.typecheck_passed }}" >> $GITHUB_STEP_SUMMARY
            echo "- Tests: ${{ steps.quality.outputs.tests_passed }}/${{ steps.quality.outputs.tests_run }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Error:** ${{ steps.parse.outputs.error_message }}" >> $GITHUB_STEP_SUMMARY
          fi
